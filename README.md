# iOS Design Patterns Demo

This repository contains a demonstration of various design patterns implemented in Swift for iOS development. The design patterns are categorized into creational, structural, and behavioral patterns to provide a comprehensive understanding of their usage.

## Table of Contents

- [Introduction](#introduction)
- [Design Patterns](#design-patterns)
  - [Creational Patterns](#creational-patterns)
  - [Structural Patterns](#structural-patterns)
  - [Behavioral Patterns](#behavioral-patterns)
- [Getting Started](#getting-started)
- [Contributing](#contributing)
- [License](#license)

## Introduction

Understanding design patterns is crucial for building robust and maintainable iOS applications. This repository serves as a reference for developers to explore different design patterns and their practical implementations in Swift.

## Design Patterns

### Creational Patterns

1. **Singleton Pattern**: Ensure a class has only one instance and provide a global point of access to it.
2. **Factory Method Pattern**: Define an interface for creating an object, but let subclasses alter the type of objects that will be created.
3. **Abstract Factory Pattern**: Provide an interface for creating families of related or dependent objects without specifying their concrete classes.
4. **Builder Pattern**: Separate the construction of a complex object from its representation, allowing the same construction process to create various representations.

### Structural Patterns

1. **Adapter Pattern**: Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn't otherwise because of incompatible interfaces.
2. **Decorator Pattern**: Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality.
3. **Facade Pattern**: Provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use.
4. **Composite Pattern**: Compose objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly.

### Behavioral Patterns

1. **Observer Pattern**: Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.
2. **Strategy Pattern**: Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.
3. **Command Pattern**: Encapsulate a request as an object, thereby parameterizing clients with queues, requests, and operations.
4. **Chain of Responsibility Pattern**: Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request.

## Getting Started

To run the demo code on your local machine, follow these steps:

1. Clone the repository:

   ```bash
   git clone https://github.com/adi-sharma26/design_patterns.git
